from vizier import pyvizier as vz
import numpy as np
import torch
import pickle
                    
centers = {
    'LunarLand':torch.tensor([0.41210892, 0.8448102,  0.47419073, 0.18224361, 0.39326157, 
                              0.70932506, 0.28846184, 0.53389306, 0.0020688,  0.70939515, 
                              0.11223617, 0.033104  ]),
    'RobotPush':torch.tensor([0.41973722, 0.71034812, 0.73111495, 0.33874836, 
                              0.69692345, 0.4986918,  0.58955414, 0.16659622, 
                              0.11988188, 0.95205255, 0.88355418, 0.29988643,
                              0.095647,   0.31748265]),
    'Rover': torch.tensor([0.01602924, 0.16642377, 0.18237113, 0.03353382, 0.41124133, 0.42245292,
                           0.00707353, 0.10983336, 0.41509733, 0.22277063, 0.32910567, 0.47408313,
                           0.28169449, 0.06454428, 0.1233088 , 0.38724173, 0.36914349, 0.43852703,
                           0.27432707, 0.16041871, 0.06474964, 0.48953182, 0.08822084, 0.53879451,
                           0.17309441, 0.35760608, 0.24053643, 0.47047524, 0.47467989, 0.03343116,
                           0.38284842, 0.61781459, 0.0945775 , 0.06175058, 0.22795625, 0.13281982,
                           0.02328893, 0.15478563, 0.22417962, 0.03578619, 0.05789552, 0.03693963,
                           0.19187214, 0.40362205, 0.10665334, 0.04158815, 0.54265102, 0.31012696,
                           0.33323145, 0.25422306, 0.05642867, 0.00196058, 0.57354732, 0.94900599,
                           0.54319996, 0.64702857, 0.94747889, 0.17960919, 0.62659977, 0.89840602,]),
    'superconductor': torch.tensor([
        12.17380667,  0.        ,  1.81547826,  4.6391099 , 48.33289074, 40.83432545,
         5.77524993, 10.03317587,  0.13322306,  0.        ,  3.59238037,  8.33453913,
        79.32729773, 66.94062473, 10.61235429,  6.75433536,  2.73479395,  0.,
         3.14468627, 23.69978803,  4.74890639, 36.49750374, 41.44620083, 32.22966418,
         3.72912599,  1.30313886,  6.97288641, 40.12384957, 88.84600652,  9.15548268,
         2.20303754, 15.10803437,  7.73076836, 11.7060874 ,  2.69711962,  0.,
         3.61219647,  0.55628783,  0.37854777,  0.50139746, 75.44864209, 11.57301414,
         0.28770857, 21.28465791,  4.7331522 ,  5.45553218,  0.17394973, 22.08192222,
         4.97948213, 46.26354147, 64.61286692, 64.95052757,  0.10039501,  0.,
         2.07670963, 17.46547218, 10.8180048 ,  0.20719411, 62.21888636,  2.62948638,
         0.        ,  3.54029323,  3.78031098,  3.79382546,  4.72298181,  0.24382178,
         3.62672165,  2.37435912,  4.30326354, 13.07674991,  3.98714008, 11.66030798,
        11.34178527,  9.01325502, 91.74317141,  9.01416939, 26.851883  ,  1.98805635,
        17.45401784,  0.3925093 ,  4.13568547,  4.12674031, 10.99516874,  0.,
         0.        ,  0.        ,]),   
    'ant':  torch.tensor([
          34004637e-03,  1.18690711e-02,  2.59877459e-02,  1.09615868e+012588,   
        3.14101850e+01,  9.86020624e+00,  4.12699272e+00,  6.67111953e+002589,
        6.23425499e+00,  2.75326464e+01,  2.65738317e+01,  1.63001989e+012590,
        1.88474921e-01,  2.10687067e-01,  3.63727519e-01,  4.12639028e-032591,
        1.53313060e-02,  1.07925565e-02, -1.92211738e+01,  2.77383238e+012592,
        1.11910541e+02, -3.62288988e+00,  1.14565741e+01, -1.53449212e+012593,
        2.46665675e+01,  1.81383839e+01,  2.05511275e+01,  1.94643448e-012594,
        2.36818836e-01,  3.23333788e-01,  2.05121409e-03,  8.89590456e-032595,
        6.25400849e-03,  6.84971527e+00,  8.24739836e+00,  1.82920034e+022596,
        1.60584749e+01,  4.77187812e+00, -2.47102591e+01,  3.26814084e+012597,
        7.88475068e+01,  2.61036097e+01,  1.93582848e-01,  1.83639434e-012598,
        3.65647051e-01, -4.65510172e-03,  4.75470192e-03,  1.23402391e-022599,
        2.12412937e+00, -4.31490782e-01, -6.23647723e+01,  2.34343882e-012600,
        4.53565749e+00, -2.47605237e+01,  3.14255988e+01,  6.78052887e+012601,
        2.06015398e+01,  2.29477669e-01,  1.91441417e-01,  3.84382634e-01,
    ]),
    'dkitty': torch.tensor([
         0.08926125,  0.14538631,  0.        ,  0.48543553, -2.83417342,  0.13426012193,
        -0.62838369,  0.4433843 ,  1.27829811,  0.77114038, -1.70172827,  1.052737232194,
         0.09550191,  0.08877216, -0.08228553,  0.12495932,  0.        ,  0.068647912195,
         4.17814865,  0.67367299,  0.85181058,  0.39754687,  0.97894775,  0.704902152196,
        -1.47443869,  1.02681234,  0.09998477,  0.09059566, -0.08656697, -0.106283822197,
         0.        ,  0.24882642,  3.65217375,  0.08715291, -0.20628981,  0.283240382198,
         1.22248628,  0.78001737, -0.32468888,  0.769342  ,  0.09863811,  0.098966072199,
         0.08866265, -0.10806467,  0.        , -0.04522851, -3.66048468, -0.105785862200,
        -0.19452985,  0.46775583,  0.95818661,  0.7192896 , -0.90791765,  0.901752392201,
         0.09585014,  0.09047566,
    ])
}

class Sphere2D:
    def __init__(self, center: tuple, dim):
        self.dim = dim
        self.center = center.clone()
    
    def __call__(self, arr: torch.Tensor) -> torch.Tensor:
        if arr.dim() == 1 and self.dim == 2:
            arr = arr.unsqueeze(0)
        if arr.dim() != 2 or arr.size(1) != self.dim:
            raise ValueError(f'Input tensor must be 2D with shape (n, {self.dim}).')
        return torch.sum((arr - self.center) ** 2, dim=1)*-1
    
def problem_statement(search_space_id, dataset_id):
    # lb, ub = 0, 1
    with open('bounds.pkl', 'rb') as f:
        bounds = pickle.load(f)
    print(bounds)
    func = 'dkitty'
    lb = torch.tensor(bounds[func]['lb'])
    ub = torch.tensor(bounds[func]['ub'])
    center = centers[func].clone()
    dim = center.shape[0]
    f = Sphere2D(center = torch.clamp(center, lb, ub), dim=dim)
    
    problem = vz.ProblemStatement()
    root = problem.search_space.root
    for i in range(dim):
        root.add_float_param('x{}'.format(i), lb[i], ub[i])
    metric = vz.MetricInformation(
        name='obj', goal=vz.ObjectiveMetricGoal.MAXIMIZE,
    )
    problem.metric_information.append(metric)
    return problem, f

# from vizier import pyvizier as vz

# from problems.synthetic import SyntheticTorch


# def problem_statement(search_space_id, dataset_id):
#     dim = 100
#     lb, ub = -5, 5
#     f = SyntheticTorch(
#         search_space_id, 
#         dataset_id, 
#         dim,
#         lb,
#         ub,
#     )
#     problem = vz.ProblemStatement()
#     root = problem.search_space.root
#     for i in range(f.dim):
#         root.add_float_param('x{}'.format(i), lb, ub)
#     metric = vz.MetricInformation(
#         name='obj', goal=vz.ObjectiveMetricGoal.MAXIMIZE,
#     )
#     problem.metric_information.append(metric)
#     return problem, f
